import pandas as pd
from datetime import datetime
import os

def process_date(file_path, path):
    # Extract date from file name and format it
    target_date_str = os.path.basename(file_path).split('.')[0]
    target_date = datetime.strptime(target_date_str, '%Y%m%d').strftime('%Y-%m-%d')

    # Get the dates for the target date and the previous 4 days
    dates_to_load = get_previous_n_days_inclusive(target_date_str, 4)

    # Check if we have enough data
    if len(dates_to_load) < 4:
        print(f"Not enough data for date: {target_date}. Skipping.")
        return None

    # Filter and read the relevant files
    files_to_read = [os.path.join(path, f"{date}.parquet") for date in dates_to_load if os.path.exists(os.path.join(path, f"{date}.parquet"))]
    df = pd.concat([pd.read_parquet(file) for file in files_to_read], ignore_index=True)

    # Reset the index to ensure it's unique and sort by ticker and date
    df.reset_index(drop=True, inplace=True)
    df.sort_values(by=['ticker', 'date'], inplace=True)

    # Convert the 'date' column to datetime objects
    df['date'] = pd.to_datetime(df['date'], format='%Y-%m-%d')

    # Define time intervals in terms of 5-minute bars
    intervals = {'5mins': 1, '15mins': 3, '30mins': 6, '1hour': 12, '3hours': 36, '5hours': 60, '1day': 78*1, '3days': 78*3}

    # Compute historical returns for each interval
    for interval_name, interval_bars in intervals.items():
        df[f'hist_ret_{interval_name}'] = df.groupby('ticker')['ret'].apply(
            lambda x: x.iloc[::-1].rolling(window=interval_bars, min_periods=1).apply(
                lambda y: (y + 1).prod() - 1, raw=True).iloc[::-1])

    # Filter the DataFrame to include only the rows for the input date
    df = df[df['date'] == pd.to_datetime(target_date)]

    print(f"Processed data for date: {target_date}")
    return df





# Compute historical returns for each interval
for interval_name, interval_bars in intervals.items():
    # Apply a lambda function to calculate compounded return for each group
    # We reverse the DataFrame order for rolling backward
    df[f'hist_ret_{interval_name}'] = df.groupby('ticker')['ret'].apply(
        lambda x: x.iloc[::-1].rolling(window=interval_bars, min_periods=1).apply(
            lambda y: ((y + 1).cumprod()[-1]) - 1, raw=True).iloc[::-1])




# Compute historical returns for each interval
for interval_name, interval_bars in intervals.items():
    # Apply the rolling function in a backward-looking manner
    df[f'hist_ret_{interval_name}'] = df.groupby('ticker')['ret'].apply(
        lambda x: x.iloc[::-1]  # Reverse the order for backward-looking rolling
            .rolling(window=interval_bars, min_periods=1)
            .apply(lambda y: ((y + 1).cumprod()[-1]) - 1, raw=True)
            .iloc[::-1]  # Reverse the order back to the original
    )

